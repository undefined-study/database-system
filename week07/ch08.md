# Chapter08. 배열

## 배열의 선언과 사용

- 동일한 자료형을 저장할 저장 공간이 많이 필요한 경우에 배열(array)을 사용한다.

- 배열을 사용하면 같은 형태의 많은 데이터를 메모리에 연속적으로 저장해놓고 이를 반복문 등으로 처리할 수 있다.

### 배열의 선언

- 배열도 다른 자료형과 마찬가지로 선언을 통해 저장 공간을 확보한다.

  - 각각의 변수를 하나씩 선언하는 것과, 하나의 변수명으로 배열로 선언하는 것의 전체 저장 공간 크기는 같다. 예를 들어 int형(4byte) 데이터가 5개 필요하다고 하면,

    ```c
      // 1번
      int a, b, c, d, e;

      // 2번
      int ary[5];
      ```

    - 1번 방법과 2번 방법이 차지하는 전체 저장 공간의 크기는 총 20byte로 동일하다.

    - 하지만 메모리에 할당되는 방식에는 차이가 있다.

      - 변수: 각각의 공간에 이름을 지정 (예: 4바이트 공간 각각에 a, b, c, .. 이름 붙임)

      - 배열: 메모리에 연속된 공간이 할당되고, 이 영역에 하나의 이름이 붙는다. (예: 20바이트 공간 하나에 ary 이름 붙임)

- 배열 선언 방법

  ```c
  자료형 배열명[요소개수];

  // 예)
  int ary[5];
  ```

  - <b>배열을 선언할 때</b>와 <b>배열 요소를 사용할 때</b> 대괄호 `[]` 안의 숫자는 의미가 다르다.

    - 선언할 때: 배열에 존재하는 요소의 전체 개수를 나타냄. (예: `int ary[5];`)

    - 사용할 때: 배열에서 몇 번째에 있는 요소인지를 나타냄. (예: `ary[4] = 22;`)

- C언어에서 배열 사용할 때 신기한 점은, 배열 크기를 벗어나는 index를 지정할 경우 결과를 예측할 수 없다는 점이다. 다른 언어들과 비교해보면..:

    - 자바스크립트

      ```js
      const ary = [1, 2, 3, 4, 5];

      console.log(ary[4]); // 5
      console.log(ary[5]); // undefined

      // * 범위 밖의 index로 접근하려고 할 경우 undefined를 반환
      ```

    - 파이썬

      ```py
      ary = [1, 2, 3, 4, 5]

      print(ary[4]) # 5
      print(ary[5]) # ! IndexError: list index out of range

      # 범위 밖의 index로 접근하려고 할 경우 index error 발생
      ```

    - ✅ C언어

      ```c
      int ary[5] = {1, 2, 3, 4, 5};

      printf("%d\n", ary[4]); // 5

      printf("%d\n", ary[5]); // 1
      printf("%d\n", ary[499]); // 1196380752
      // ! warning: array index 499 is past the end of the array
      // ! (which contains 5 elements) [-Warray-bounds]
      ```

    C언어는 위와 같이 컴파일러가 경고 메시지를 보여주기는 하나 컴파일과 실행은 정상적으로 진행된다. 이렇게 무사히(?) 실행까지 되는 이유는 메모리에 포인터 연산을 통해 접근하는데 이때 배열의 시작 주소값 + index에 위치해있는 영역에 접근하므로 해당 영역, 배열이 아닌 영역에 접근하게 되기 때문이다.

### 배열 초기화

- 배열도 변수와 마찬가지로, 최초 할당된 저장 공간에는 쓰레기 값이 저장되어 있다.

- 초기화 방법

  1. 기본적인 초기화 방법 (선언과 동시에 초기화)

      ```c
      int ary[5] = {1, 2, 3, 4, 5};
      ```

  2. 초깃값이 배열 요소 개수보다 적은 경우

      ```c
      int ary[5] = {1, 2, 3};
      ```

      일단 왼쪽부터 차례로 초기화를 한다. 그리고 남은 배열 요소는 위와 같은 int형 배열의 경우에는 모두 0으로 채워진다.

  3. 자동 초기화 기능

      ```c
      int ary[5] = {0};
      ```

      배열 요소 개수를 전부 0으로 초기화한다.

  4. 배열 요소 개수를 생략하는 경우

      ```c
      int ary[] = {1, 2, 3};
      ```

      이런 경우에는 컴파일러가 초깃값 개수만큼 배열 요소 개수를 정하고 저장 공간을 할당한다.

- <b>배열 초기화는 선언 시 최초 한 번만 가능</b>하고, 그 이후에는 초기화 때처럼 저렇게 중괄호를 사용해서 대입 연산으로 한 번에 값을 바꾸는 것은 불가능하다.

  - 배열 요소에 일일이 값을 대입해서 값을 바꾸는 것은 가능하다. (예: `ary[0] = 100;`)

### sizeof 연산자를 활용한 배열 처리

- 반복문을 쓸 때 반복 횟수를 정해줘야 하는데, 배열 요소의 개수를 바꿀 때마다 반복문도 수정해야 한다면 번거로울 것이다. 그러한 번거로운 작업을 하지 않기 위해 다음과 같이 배열 요소 개수를 직접 계산하여 반복문에 사용한다.

  ```c
  int 배열크기변수명 = sizeof(배열명) / sizeof(배열 요소);

  // 예)
  int score[5] = {100, 200, 300, 400, 500};
  int count = sizeof(score) / sizeof(score[0]); // 20 / 4 = 5
  ```

## 문자를 저장하는 배열

- 단어를 저장하는 가장 좋은 방법은 배열!

  > 단어는 알파벳을 <b>연속</b>으로 적고, 그 <b>순서</b>에 따라 뜻이 달라진다.
  >
  > 👉 단어를 컴퓨터에서 데이터로 처리하려면, 메모리에 문자(character)를 <b>순서</b>에 맞게, <b>연속</b>으로 저장해야 한다.

- char형 배열을 사용하면 된다. 이때 주의할 점:

  - 배열의 크기는 최대한 넉넉하게 선언하기 (문자열 길이가 일정하지 않을 경우)

  - 배열 요소 개수는 최소한 `문자열 길이 + 1`로 지정하기

### char형 배열의 선언과 초기화

- char형 배열을 선언할 때 중요한 점은, 저장할 문자열의 길이보다 <b>최소한 하나 이상 크게</b> 범위를 잡아야 한다는 것이다.

  - 여분의 공간이 필요한 이유: 널 문자(`\0`)를 저장하기 위함.

  - 널 문자(null character)

    - 아스키 코드 값은 0이며, 문자 상수로는 `\0`으로 표현

    - 주요 기능: <b>문자열의 끝</b>을 나타낸다.

    - `printf` 함수 등이 char형 배열의 크기와 관계없이 초기화된 문자열만을 정확히 출력하는 것도 널 문자 덕분! `printf` 함수는 char형 배열에서 널 문자가 나올 때까지만 출력하도록 만들어졌다. 문자열을 처리하는 모든 함수들은 이러한 규칙을 따른다.

    - `scanf` 함수는 사용자가 입력한 문자열 다음에 자동으로 널 문자를 추가하여 문자열의 끝을 표시한다.

- 초기화하는 문자들은 배열의 처음부터 차례로 저장된다. 이때 남는 배열 요소에는 자동으로 널 문자가 채워진다.

- 문자열을 저장할 용도로 char형 배열을 사용할 때, 초기화는 다른 자료형의 배열과 달리 <b>중괄호 없이</b> 문자열 상수로 직접 초기화한다. (예: `char str[80] = "applejam";`)

### 문자열 대입

- 초기화 이후에 문자열을 수정하려면 대입 연산자를 사용하는 것은 불가능하며 `strcpy` 함수를 사용해야 한다.

  - `string.h` 헤더 파일

  - char형 배열에 새로운 문자열을 저장하는 함수

  - 저장한 문자열의 길이를 파악하여 딱 그 길이만큼만 char형 배열에 복사한다. 문자열 끝에 널 문자도 자동으로 붙여준다.

  - 사용 방법

    ```c
    strcpy(저장될 배열명, 저장할 문자열);

    // 예)
    char test_char[20] = "hello, world!";
    printf("%s\n", test_char); // hello, world!

    // test_char = "hi";
    // ! 식이 수정할 수 있는 lvalue여야 합니다.C/C++(137)

    strcpy(test_char, "hi");
    printf("%s\n", test_char); // hi
    ```

- 대입 연산자를 사용해서 바꾸는 것은 불가능한 이유

  ```c
  test_char = "hi"; // 🙅🏻‍♀️
  ```

  - 이와 같이 대입 연산자를 쓸 수 없는 이유는, 배열명(`test_char`)은 컴파일 과정에서 해당 배열이 할당된 메모리의 주소 값으로 바뀌기 때문이다.

  - 예를 들어 `test_char`의 시작 주소값이 32530이라고 하면 위의 식은 컴파일 과정에서 다음과 같이 바뀌게 된다. 결국 대입 연산자의 왼쪽에 상수가 오게 되는 셈이다.

    ```c
    32530 = "hi"; // 🙅🏻‍♀️
    ```

### 문자열 전용 입출력 함수: gets, puts

(귀찮아서 문서로 대체합니다..)

- [gets](https://devdocs.io/c/io/gets) : 문자열 입력

  - `scanf` 함수와 달리 빈칸을 포함하여 입력할 수 있음.

- [puts](https://devdocs.io/c/io/puts) : 문자열 출력

  - `printf`와 달리 문자열을 출력한 후에 자동으로 줄을 바꿀 수 있음.
