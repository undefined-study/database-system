# Chapter04. 연산자

## 산술 연산자, 관계 연산자, 논리 연산자

### 산술 연산자

  - 더하기(`+`), 빼기(`-`), 곱하기(`*`), 나누기(`/`), 나머지(`%`)

  - 나누기 연산자를 사용할 땐, 피연산자의 형태에 따라 결과가 달라진다.

    - 정수끼리만 연산할 때: <b>몫</b>을 구함. (즉 연산 결과가 정수)

    - 실수끼리만 연산할 때: 소수점까지 구함. (즉 연산 결과가 실수)

    - 이 두 가지 케이스 외에 다른 케이스에 대해선 4-2에서 설명 예정

  - 나머지 연산자의 경우, 피연산자로는 반드시 <b>정수</b>만을 사용해야 한다.

    - 실수 연산에는 "나머지"의 개념이 없기 때문

### 대입 연산자

- `=`

- 오른쪽 수식의 결과를 왼쪽 변수에 저장

  - 오른쪽 수식: 연산자를 사용한 식 or 상수 or 변수

### 증감 연산자

- `++a`, `a++`

- 증감 연산자는 단항 연산자로, 피연산자의 값을 1씩 증가/감소시킨다.

- 증감 연산자는 반복문에서 루프마다 값을 1씩 증감시킬 때 자주 사용한다.

- 증감 연산자는 대입 연산을 포함하고 있다. 즉, 연산 수행 시 피연산자의 값이 바뀐다.

- 피연산자를 기준으로 해서 증감 연산자의 위치에 따라 <b>전위 표기(prefix, `++a`)</b>와 <b>후위 표기(postfix, `a++`)</b>로 구분한다.

  - 전위 표기: 값을 먼저 증감시키고 연산 ㄱㄱ

  - 후위 표기: 연산을 하고 나서 값을 증감시킴.

    - 증감 연산자의 후위 표기는 다른 연산자와 함께 사용할 경우 가장 마지막에 계산된다고 보면 된다.

  ```c
  #include <stdio.h>

  int main()
  {
    int a = 2, b = 2;
    int prefix, postfix;

    prefix = ++a * 3;
    postfix = b++ * 3;

    printf("prefix: %d\n", prefix); // prefix: 9
    printf("postfix: %d", postfix); // postfix: 6
  }
  ```

### 관계 연산자

- 종류

  - 대소 관계 연산자: `<`, `>`, `<=`, `>=`

  - 동등 관계 연산자: `==`, `!=`

- 관계 연산자의 연산 결과값은 `1` 또는 `0` (따라서 해당 결과값을 받는 변수는 `int`형으로 선언해야 한다.)

  - 컴파일러는 참/거짓을 `1`과 `0`으로 판단하므로, 관계식을 실행 조건 검사에 사용할 수 있다.

  - 사실 `1` 뿐만 아니라 `0`이 아닌 값들을 참으로 판단하나, 그 중 `1`을 대표로 사용한다.

  - [C언어는 boolean 타입이 없다?](https://medium.com/@kyle_seongwoo_jun/c%EC%97%90%EC%84%9C-bool-%ED%83%80%EC%9E%85-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0-105ecaf1db02)

    - C 언어에는 원래 논리 자료형(boolean 타입)이 없었고 대신 숫자로 참/거짓을 표현해왔다. 하지만 1999년 C99에서 bool 타입이 표준이 되어, C 언어에도 논리 자료형이 존재하게 되었다! bool 타입 사용하려면 `stdbool.h` 헤더 파일을 include 하면 된다.

      ```c
      #include <stdio.h>
      #include <stdbool.h>

      int main()
      {
        bool is_round = true;

        printf("지구는 %s.\n", is_round ? "둥글다" : "각져있다"); // 지구는 둥글다.
      }
      ```

      까보면 이렇게 생겼다.

      ```h
      #define bool _Bool
      #define true 1
      #define false 0
      ```

### 논리 연산자

- 참/거짓을 판단

- `&&`(논리곱 연산자(AND)), `||`(논리합 연산자(OR)), `!`(논리부정 연산자(NOT))

- short circuit rule(숏 서킷 룰)

  - 단축 평가

  - 우항까지 살펴보지 않고, 좌항만으로 `&&`, `||` 연산 결과를 판별하는 기능

  - 불필요한 연산을 줄여 실행 속도를 높일 수 있음.

### 연산식은 컴퓨터 내부에서 어떻게 처리될까요?

- 연산 과정은 다음과 같이 처리된다.

  1. 로드(load): 메모리에 있는 피연산자 값을 레지스터(CPU의 저장공간)에 "복사"

  2. 레지스터에 저장된 값에 대하여 ALU가 연산을 수행

    - [ALU(Arithmetic Logic Unit, 산술논리연산장치)](https://ko.wikipedia.org/wiki/%EC%82%B0%EC%88%A0_%EB%85%BC%EB%A6%AC_%EC%9E%A5%EC%B9%98) - 산술 연산과 논리 연산을 계산하는 디지털 회로

  3. 연산 결괏값을 레지스터에 임시 저장

  4. 스토어(store): 대입 연산 수행 👉 결괏값이 메모리에 있는 변수에 복사됨.

### 레지스터와 메모리(RAM) 비교

- 우선 레지스터(register)의 사전적 의미는 '기록부', '등록부'

- 레지스터에는 "연산할 데이터"와 "연산 후의 결과"가 <b>임시 저장</b>된다.

- 레지스터는 *CPU 클럭과 1:1 동기화되어 있어* RAM에 비해 빠르다.

- 레지스터는 다음 연산을 위해 계속 사용되므로, 연산 결과를 날려버리지 않으려면 메모리에 옮겨놓아야 한다.

## 그 외 유용한 연산자
